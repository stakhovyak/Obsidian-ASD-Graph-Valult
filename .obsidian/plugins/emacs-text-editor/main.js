/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => EmacsTextEditorPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  enableKeyRepeat: true,
  keyRepeatDelay: 500,
  // Initial delay before repeat starts (ms)
  keyRepeatInterval: 50
  // Interval between repeats (ms)
};
var insertableSpecialKeys = [
  "Comma",
  "Period",
  "Slash",
  "Semicolon",
  "Quote",
  "BracketLeft",
  "BracketRight",
  "Backslash",
  "Backquote",
  "Minus",
  "Equal"
];
var EmacsTextEditorPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.pluginTriggerSelection = false;
    this.disableSelectionWhenPossible = false;
    this.currentRepeatTimeouts = /* @__PURE__ */ new Map();
  }
  // async so can wait for settings before full init
  async onload() {
    console.log("loading plugin: Emacs text editor");
    await this.loadSettings();
    this.addSettingTab(new EmacsKeyRepeatSettingTab(this.app, this));
    this.registerDomEvent(document, "keydown", (e) => {
      if (isEventInterruptSelection(e)) {
        this.disableSelectionWhenPossible = true;
        this.pluginTriggerSelection = false;
      }
      if (this.settings.enableKeyRepeat) {
        this.handleKeyRepeat(e);
      }
    });
    this.registerDomEvent(document, "keyup", (e) => {
      const keyId = this.getKeyId(e);
      this.stopKeyRepeat(keyId);
    });
    this.registerDomEvent(window, "blur", () => {
      this.stopAllKeyRepeats();
    });
    this.registerEvent(this.app.workspace.on("active-leaf-change", () => {
      this.stopAllKeyRepeats();
    }));
    this.addCommand({
      id: "forward-char",
      name: "Forward char",
      hotkeys: [{ modifiers: ["Ctrl"], key: "f" }],
      editorCallback: (editor, _) => {
        this.moveForwardOneChar(editor);
      }
    });
    this.addCommand({
      id: "backward-char",
      name: "Backward char",
      hotkeys: [{ modifiers: ["Ctrl"], key: "b" }],
      editorCallback: (editor, _) => {
        this.moveBackOneChar(editor);
      }
    });
    this.addCommand({
      id: "next-line",
      name: "Next line",
      hotkeys: [{ modifiers: ["Ctrl"], key: "n" }],
      editorCallback: (editor, _) => {
        this.moveNextLine(editor);
      }
    });
    this.addCommand({
      id: "previous-line",
      name: "Previous line",
      hotkeys: [{ modifiers: ["Ctrl"], key: "p" }],
      editorCallback: (editor, _) => {
        this.movePreviousLine(editor);
      }
    });
    this.addCommand({
      id: "forward-word",
      name: "Forward word",
      hotkeys: [{ modifiers: ["Alt"], key: "f" }],
      editorCallback: (editor, _) => {
        this.moveForwardOneWord(editor);
      }
    });
    this.addCommand({
      id: "backward-word",
      name: "Backward word",
      hotkeys: [{ modifiers: ["Alt"], key: "b" }],
      editorCallback: (editor, _) => {
        this.moveBackOneWord(editor);
      }
    });
    this.addCommand({
      id: "move-end-of-line",
      name: "Move end of line",
      hotkeys: [{ modifiers: ["Ctrl"], key: "e" }],
      editorCallback: (editor, _) => {
        this.withSelectionUpdate(editor, () => {
          const cursor = editor.getCursor();
          const lineContent = editor.getLine(cursor.line);
          editor.setCursor({
            line: cursor.line,
            ch: lineContent.length
          });
        });
      }
    });
    this.addCommand({
      id: "move-beginning-of-line",
      name: "Move cursor to beginning of line",
      hotkeys: [{ modifiers: ["Ctrl"], key: "a" }],
      editorCallback: (editor, _) => {
        this.withSelectionUpdate(editor, () => {
          const cursor = editor.getCursor();
          editor.setCursor({ line: cursor.line, ch: 0 });
        });
      }
    });
    this.addCommand({
      id: "beginning-of-buffer",
      name: "Beginning of buffer",
      hotkeys: [{ modifiers: ["Alt", "Shift"], key: "," }],
      editorCallback: (editor, _) => {
        this.withSelectionUpdate(editor, () => {
          editor.exec("goStart");
        });
      }
    });
    this.addCommand({
      id: "end-of-buffer",
      name: "End of buffer",
      hotkeys: [{ modifiers: ["Alt", "Shift"], key: "." }],
      editorCallback: (editor, _) => {
        this.withSelectionUpdate(editor, () => {
          editor.exec("goEnd");
        });
      }
    });
    this.addCommand({
      id: "kill-line",
      name: "Kill line",
      hotkeys: [{ modifiers: ["Ctrl"], key: "k" }],
      editorCallback: (editor, _) => {
        this.disableSelection(editor);
        const cursor = editor.getCursor();
        const lineContent = editor.getLine(cursor.line);
        if (lineContent === "") {
          editor.exec("deleteLine");
        } else {
          editor.setSelection(cursor, {
            line: cursor.line,
            ch: lineContent.length
          });
          this.putSelectionInClipboard(editor, 1 /* Cut */);
          editor.setCursor(cursor);
        }
      }
    });
    this.addCommand({
      id: "delete-char",
      name: "Delete char",
      hotkeys: [{ modifiers: ["Ctrl"], key: "d" }],
      editorCallback: (editor, _) => {
        this.disableSelection(editor);
        this.withDeleteInText(editor, () => {
          editor.exec("goRight");
        });
      }
    });
    this.addCommand({
      id: "kill-word",
      name: "Kill word",
      hotkeys: [{ modifiers: ["Alt"], key: "d" }],
      editorCallback: (editor, _) => {
        this.withDeleteInText(editor, () => {
          editor.exec("goWordRight");
        });
      }
    });
    this.addCommand({
      id: "backward-kill-word",
      name: "Backward kill word",
      hotkeys: [{ modifiers: ["Alt"], key: "Backspace" }],
      editorCallback: (editor, _) => {
        this.withDeleteInText(editor, () => {
          editor.exec("goWordLeft");
        });
      }
    });
    this.addCommand({
      id: "kill-ring-save",
      name: "Kill ring save",
      hotkeys: [{ modifiers: ["Alt"], key: "w" }],
      editorCallback: (editor, _) => {
        this.putSelectionInClipboard(editor, 0 /* Copy */);
      }
    });
    this.addCommand({
      id: "kill-region",
      name: "Kill region",
      hotkeys: [{ modifiers: ["Ctrl"], key: "w" }],
      editorCallback: (editor, _) => {
        this.putSelectionInClipboard(editor, 1 /* Cut */);
      }
    });
    this.addCommand({
      id: "yank",
      name: "Yank",
      hotkeys: [{ modifiers: ["Ctrl"], key: "y" }],
      editorCallback: async (editor, _) => {
        const clipboardContent = await navigator.clipboard.readText();
        const cursor = editor.getCursor();
        if (!this.getCurrentSelectionStart(editor)) {
          editor.replaceRange(clipboardContent, cursor);
        } else {
          editor.replaceSelection(clipboardContent);
          this.disableSelection(editor);
        }
        editor.setCursor(
          cursor.line,
          cursor.ch + clipboardContent.length
        );
        document.dispatchEvent(new ClipboardEvent("paste"));
      }
    });
    this.addCommand({
      id: "set-mark-command",
      name: "Set mark command",
      hotkeys: [{ modifiers: ["Ctrl"], key: "Space" }],
      editorCallback: (editor, _) => {
        if (this.pluginTriggerSelection) {
          this.disableSelection(editor);
        } else {
          this.pluginTriggerSelection = true;
        }
        this.disableSelectionWhenPossible = false;
      }
    });
    this.addCommand({
      id: "keyboard-quit",
      name: "Keyboard-quit",
      hotkeys: [{ modifiers: ["Ctrl"], key: "g" }],
      editorCallback: (editor, _) => {
        this.disableSelection(editor);
      }
    });
    this.addCommand({
      id: "undo",
      name: "Undo",
      hotkeys: [{ modifiers: ["Ctrl"], key: "/" }],
      editorCallback: (editor, _) => {
        editor.undo();
      }
    });
    this.addCommand({
      id: "redo",
      name: "Redo",
      hotkeys: [{ modifiers: ["Ctrl", "Shift"], key: "-" }],
      editorCallback: (editor, _) => {
        editor.redo();
      }
    });
    this.addCommand({
      id: "recenter-top-bottom",
      name: "Recenter",
      hotkeys: [{ modifiers: ["Ctrl"], key: "l" }],
      editorCallback: (editor, _) => {
        const cursor = editor.getCursor();
        const range = {
          from: { line: cursor.line, ch: cursor.ch },
          to: { line: cursor.line, ch: cursor.ch }
        };
        editor.scrollIntoView(range, true);
      }
    });
    this.addCommand({
      id: "forward-paragraph",
      name: "Forward paragraph",
      hotkeys: [{ modifiers: ["Alt", "Shift"], key: "]" }],
      editorCallback: async (editor, _) => {
        this.withSelectionUpdate(editor, () => {
          this.moveToNextParagraph(editor, 0 /* Forward */);
        });
      }
    });
    this.addCommand({
      id: "backward-paragraph",
      name: "Backward paragraph",
      hotkeys: [{ modifiers: ["Alt", "Shift"], key: "[" }],
      editorCallback: async (editor, _) => {
        this.withSelectionUpdate(editor, () => {
          this.moveToNextParagraph(editor, 1 /* Backward */);
        });
      }
    });
    this.addCommand({
      id: "upcase-word",
      name: "Upcase word",
      editorCallback: async (editor, _) => {
        this.transformWordAtCursor(editor, (word) => word.toUpperCase());
      }
    });
    this.addCommand({
      id: "downcase-word",
      name: "Downcase word",
      editorCallback: async (editor, _) => {
        this.transformWordAtCursor(editor, (word) => word.toLowerCase());
      }
    });
    this.addCommand({
      id: "capitalize-word",
      name: "Capitalize word",
      editorCallback: async (editor, _) => {
        this.transformWordAtCursor(editor, capitalizeOneWord);
      }
    });
    this.addCommand({
      id: "upcase-region",
      name: "Upcase region",
      editorCallback: async (editor, _) => {
        this.withSelectionUpdate(editor, () => {
          this.transformSelection(editor, (word) => word.toUpperCase());
        });
      }
    });
    this.addCommand({
      id: "downcase-region",
      name: "Downcase region",
      editorCallback: async (editor, _) => {
        this.withSelectionUpdate(editor, () => {
          this.transformSelection(editor, (word) => word.toLowerCase());
        });
      }
    });
    this.addCommand({
      id: "capitalize-region",
      name: "Capitalize region",
      editorCallback: async (editor, _) => {
        this.withSelectionUpdate(editor, () => {
          this.transformSelection(editor, capitalizeWords);
        });
      }
    });
    this.addCommand({
      id: "upcase-dwim",
      name: "Upcase dwim",
      hotkeys: [{ modifiers: ["Alt"], key: "u" }],
      editorCallback: async (editor, _) => {
        this.transformDWIM(editor, (word) => word.toUpperCase());
      }
    });
    this.addCommand({
      id: "downcase-dwim",
      name: "Downcase dwim",
      hotkeys: [{ modifiers: ["Alt"], key: "l" }],
      editorCallback: async (editor, _) => {
        this.transformDWIM(editor, (word) => word.toLowerCase());
      }
    });
    this.addCommand({
      id: "capitalize-dwim",
      name: "Capitalize dwim",
      hotkeys: [{ modifiers: ["Alt"], key: "c" }],
      editorCallback: async (editor, _) => {
        this.transformDWIM(editor, capitalizeOneWord, capitalizeWords);
      }
    });
  }
  onunload() {
    console.log("unloading plugin: Emacs text editor");
    this.stopAllKeyRepeats();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.settings.keyRepeatDelay = Math.max(25, Math.min(2e3, this.settings.keyRepeatDelay));
    this.settings.keyRepeatInterval = Math.max(10, Math.min(1e3, this.settings.keyRepeatInterval));
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  handleKeyRepeat(keyEvent) {
    if (!this.isInActiveEditor()) {
      return;
    }
    const keyId = this.getKeyId(keyEvent);
    const keyMoveFunc = this.getKeyMoveFunc(keyEvent);
    if (keyMoveFunc) {
      keyEvent.preventDefault();
      keyEvent.stopPropagation();
      if (this.currentRepeatTimeouts.has(keyId)) {
        return;
      }
      try {
        keyMoveFunc();
      } catch (error) {
        console.error("Key move function error:", error);
        return;
      }
      const timeoutId = window.setTimeout(() => {
        const intervalId = window.setInterval(() => {
          if (this.isInActiveEditor() && this.currentRepeatTimeouts.has(keyId)) {
            try {
              keyMoveFunc();
            } catch (error) {
              console.error("Key repeat interval error:", error);
              this.stopKeyRepeat(keyId);
            }
          } else {
            this.stopKeyRepeat(keyId);
          }
        }, this.settings.keyRepeatInterval);
        const repeatState = this.currentRepeatTimeouts.get(keyId);
        if (repeatState) {
          repeatState.intervalId = intervalId;
        }
      }, this.settings.keyRepeatDelay);
      this.currentRepeatTimeouts.set(keyId, { timeoutId });
    }
  }
  isInActiveEditor() {
    var _a, _b;
    const markdownView = (_b = (_a = this.app.workspace).getActiveViewOfType) == null ? void 0 : _b.call(_a, import_obsidian.MarkdownView);
    return !!(markdownView && markdownView.editor);
  }
  getKeyId(e) {
    const modifiers = [];
    if (e.ctrlKey)
      modifiers.push("ctrl");
    if (e.altKey)
      modifiers.push("alt");
    if (e.shiftKey)
      modifiers.push("shift");
    if (e.metaKey)
      modifiers.push("meta");
    return [...modifiers, e.key.toLowerCase()].join("+");
  }
  getKeyMoveFunc(e) {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeView)
      return null;
    const editor = activeView.editor;
    if (e.ctrlKey && !e.altKey && !e.shiftKey && !e.metaKey) {
      switch (e.key.toLowerCase()) {
        case "f":
          return () => this.moveForwardOneChar(editor);
        case "b":
          return () => this.moveBackOneChar(editor);
        case "n":
          return () => this.moveNextLine(editor);
        case "p":
          return () => this.movePreviousLine(editor);
      }
    }
    if (e.altKey && !e.ctrlKey && !e.shiftKey && !e.metaKey) {
      switch (e.key.toLowerCase()) {
        case "f":
          return () => this.moveForwardOneWord(editor);
        case "b":
          return () => this.moveBackOneWord(editor);
      }
    }
    return null;
  }
  stopKeyRepeat(keyId) {
    const timeout = this.currentRepeatTimeouts.get(keyId);
    if (timeout) {
      if (timeout.timeoutId) {
        clearTimeout(timeout.timeoutId);
      }
      if (timeout.intervalId) {
        clearInterval(timeout.intervalId);
      }
      this.currentRepeatTimeouts.delete(keyId);
    }
  }
  stopAllKeyRepeats() {
    this.currentRepeatTimeouts.forEach(({ timeoutId, intervalId }) => {
      if (timeoutId)
        clearTimeout(timeoutId);
      if (intervalId)
        clearInterval(intervalId);
    });
    this.currentRepeatTimeouts.clear();
  }
  moveForwardOneChar(editor) {
    this.withSelectionUpdate(editor, () => {
      editor.exec("goRight");
    });
  }
  moveBackOneChar(editor) {
    this.withSelectionUpdate(editor, () => {
      editor.exec("goLeft");
    });
  }
  moveNextLine(editor) {
    this.withSelectionUpdate(editor, () => {
      editor.exec("goDown");
    });
  }
  movePreviousLine(editor) {
    this.withSelectionUpdate(editor, () => {
      editor.exec("goUp");
    });
  }
  moveForwardOneWord(editor) {
    this.withSelectionUpdate(editor, () => {
      editor.exec("goWordRight");
    });
  }
  moveBackOneWord(editor) {
    this.withSelectionUpdate(editor, () => {
      editor.exec("goWordLeft");
    });
  }
  disableSelection(editor) {
    editor.setSelection(editor.getCursor(), editor.getCursor());
    this.pluginTriggerSelection = false;
    this.disableSelectionWhenPossible = false;
  }
  withSelectionUpdate(editor, callback) {
    if (this.disableSelectionWhenPossible) {
      this.disableSelection(editor);
    }
    const currentSelectionStart = this.getCurrentSelectionStart(editor);
    if (currentSelectionStart) {
      editor.setSelection(editor.getCursor());
    }
    callback();
    if (currentSelectionStart) {
      editor.setSelection(currentSelectionStart, editor.getCursor());
    }
  }
  getCurrentSelectionStart(editor) {
    const selections = editor.listSelections();
    if (selections.length == 0) {
      return void 0;
    }
    if (selections[0].anchor.line !== selections[0].head.line || selections[0].anchor.ch !== selections[0].head.ch) {
      return selections[0].anchor;
    }
    if (this.pluginTriggerSelection) {
      return selections[0].anchor;
    }
    return void 0;
  }
  withDeleteInText(editor, callback) {
    const cursorBefore = editor.getCursor();
    callback();
    const cursorAfter = editor.getCursor();
    editor.setSelection(cursorBefore, cursorAfter);
    this.putSelectionInClipboard(editor, 1 /* Cut */);
  }
  putSelectionInClipboard(editor, mode) {
    if (!this.getCurrentSelectionStart(editor)) {
      return;
    }
    navigator.clipboard.writeText(editor.getSelection());
    if (mode == 0 /* Copy */) {
      document.dispatchEvent(new ClipboardEvent("copy"));
    } else if (mode == 1 /* Cut */) {
      editor.replaceSelection("");
      document.dispatchEvent(new ClipboardEvent("cut"));
    }
    this.disableSelection(editor);
  }
  moveToNextParagraph(editor, direction) {
    const cursor = editor.getCursor();
    const value = editor.getValue();
    const maxOffset = value.length;
    const currentOffset = editor.posToOffset(cursor);
    if (direction === 0 /* Forward */ && currentOffset >= maxOffset || direction === 1 /* Backward */ && currentOffset === 0) {
      return;
    }
    let nextParagraphOffset = direction === 0 /* Forward */ ? maxOffset : 0;
    let foundText = false;
    let foundFirstBreak = false;
    function isNewLine(position, direction2) {
      if (direction2 === 0 /* Forward */) {
        return value[position] === "\n" || value[position] === "\r" && value[position + 1] === "\n";
      } else {
        return value[position] === "\n" || position > 0 && value[position - 1] === "\r" && value[position] === "\n";
      }
    }
    const step = direction === 0 /* Forward */ ? 1 : -1;
    let i = currentOffset;
    while (direction === 0 /* Forward */ && i < maxOffset || direction === 1 /* Backward */ && i > 0) {
      if (foundText && isNewLine(i, direction)) {
        if (foundFirstBreak) {
          nextParagraphOffset = direction === 0 /* Forward */ ? i : i + 1;
          if (direction === 0 /* Forward */ && value[i] === "\r" || direction === 1 /* Backward */ && i > 0 && value[i - 1] === "\r") {
            nextParagraphOffset += direction === 0 /* Forward */ ? 1 : -1;
          }
          break;
        } else {
          foundFirstBreak = true;
          i += step;
          continue;
        }
      } else {
        foundFirstBreak = false;
      }
      if (value[i] !== "\n" && value[i] !== "\r" && value[i] !== " ") {
        foundText = true;
      }
      i += step;
    }
    const newPos = editor.offsetToPos(nextParagraphOffset);
    editor.setCursor(newPos);
  }
  transformWordAtCursor(editor, transform) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    let ch = cursor.ch;
    while (ch < line.length && !/\w/.test(line[ch])) {
      ch++;
    }
    const start = ch;
    while (ch < line.length && /\w/.test(line[ch])) {
      ch++;
    }
    const end = ch;
    const word = line.substring(start, end);
    const newWord = transform(word);
    const range = {
      from: { line: cursor.line, ch: start },
      to: { line: cursor.line, ch: end }
    };
    editor.replaceRange(newWord, range.from, range.to);
    editor.setCursor(cursor.line, end);
  }
  transformSelection(editor, transform) {
    const selection = editor.getSelection();
    if (!selection) {
      return;
    }
    const transformedSelection = transform(selection);
    editor.replaceSelection(transformedSelection);
    this.disableSelection(editor);
  }
  transformDWIM(editor, transformOneWord, transformWords) {
    if (editor.getSelection()) {
      this.transformSelection(editor, transformWords ? transformWords : transformOneWord);
    } else {
      this.transformWordAtCursor(editor, transformOneWord);
    }
  }
};
var EmacsKeyRepeatSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Emacs Key Repeat Settings" });
    new import_obsidian.Setting(containerEl).setName("Enable key repeat").setDesc("Allow cursor movement keys to repeat when held down").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableKeyRepeat).onChange(async (value) => {
        this.plugin.settings.enableKeyRepeat = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Initial delay").setDesc(`Time before key repeat starts (25-1000ms). Current: ${this.plugin.settings.keyRepeatDelay}ms`).addSlider(
      (slider) => slider.setLimits(25, 1e3, 50).setValue(this.plugin.settings.keyRepeatDelay).setDynamicTooltip().onChange(async (value) => {
        var _a, _b, _c;
        this.plugin.settings.keyRepeatDelay = value;
        await this.plugin.saveSettings();
        (_c = (_b = (_a = slider.sliderEl.parentElement) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.querySelector(".setting-item-description")) == null ? void 0 : _c.setText(`Time before key repeat starts (0-1000ms). Current: ${value}ms`);
      })
    );
    new import_obsidian.Setting(containerEl).setName("Repeat interval").setDesc(`Time between repeats (10-1000ms). Current: ${this.plugin.settings.keyRepeatInterval}ms`).addSlider(
      (slider) => slider.setLimits(10, 1e3, 5).setValue(this.plugin.settings.keyRepeatInterval).setDynamicTooltip().onChange(async (value) => {
        var _a, _b, _c;
        this.plugin.settings.keyRepeatInterval = value;
        await this.plugin.saveSettings();
        (_c = (_b = (_a = slider.sliderEl.parentElement) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.querySelector(".setting-item-description")) == null ? void 0 : _c.setText(`Time between repeats (10-1000ms). Current: ${value}ms`);
      })
    );
    containerEl.createEl("h3", { text: "Quick Presets" });
    const presetContainer = containerEl.createEl("div", { cls: "setting-item" });
    const buttonContainer = presetContainer.createEl("div", { cls: "setting-item-control" });
    buttonContainer.createEl("button", { text: "Slow" }).addEventListener("click", async () => {
      this.plugin.settings.keyRepeatDelay = 750;
      this.plugin.settings.keyRepeatInterval = 100;
      await this.plugin.saveSettings();
      this.display();
    });
    buttonContainer.createEl("button", { text: "Medium" }).addEventListener("click", async () => {
      this.plugin.settings.keyRepeatDelay = 500;
      this.plugin.settings.keyRepeatInterval = 50;
      await this.plugin.saveSettings();
      this.display();
    });
    buttonContainer.createEl("button", { text: "Fast" }).addEventListener("click", async () => {
      this.plugin.settings.keyRepeatDelay = 25;
      this.plugin.settings.keyRepeatInterval = 25;
      await this.plugin.saveSettings();
      this.display();
    });
  }
};
function isEventInterruptSelection(e) {
  let withKeyModifier = e.ctrlKey || e.altKey;
  return e.code == "Backspace" || e.code == "Delete" || Boolean(e.code.match(/^Key[A-Z]$/)) && !withKeyModifier || Boolean(e.code.match(/^Digit[0-9]$/)) && !withKeyModifier || Boolean(e.code.match(/^Numpad[0-9]$/)) && !withKeyModifier || insertableSpecialKeys.includes(e.code) && !withKeyModifier;
}
function capitalizeOneWord(word) {
  return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
}
function capitalizeWords(selection) {
  const words = selection.split(/\b/);
  const capitalizedWords = words.map((word) => {
    if (/\w/.test(word)) {
      return capitalizeOneWord(word);
    }
    return word;
  });
  return capitalizedWords.join("");
}

/* nosourcemap */